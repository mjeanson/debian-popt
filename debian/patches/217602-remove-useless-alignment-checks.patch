Patch by Nicolas Boullis <nboullis@debian.org> and revised by Paul Martin
<pm@debian.org>.

In functions poptSaveLong and poptSaveInt, libpopt somewhat asserts that
{long,}ints are aligned on sizeof({long,}int)-byte boundaries. On m68k
with gcc-3.3 ints and long ints are 4-byte long, but are aligned on 2-bytes
boundaries at least when they are part onf a struct.

Simply remove this check, as it is quite useless.

--- a/popt.c
+++ b/popt.c
@@ -1026,8 +1026,13 @@
 
 int poptSaveLong(long * arg, unsigned int argInfo, long aLong)
 {
+#if 0
     /* XXX Check alignment, may fail on funky platforms. */
     if (arg == NULL || (((unsigned long)arg) & (sizeof(*arg)-1)))
+#else
+    /* It does! pm@debian.org */
+    if (arg == NULL)
+#endif
 	return POPT_ERROR_NULLARG;
 
     if (aLong != 0 && LF_ISSET(RANDOM)) {
@@ -1059,8 +1064,13 @@
 
 int poptSaveInt(/*@null@*/ int * arg, unsigned int argInfo, long aLong)
 {
+#if 0
     /* XXX Check alignment, may fail on funky platforms. */
     if (arg == NULL || (((unsigned long)arg) & (sizeof(*arg)-1)))
+#else
+    /* It does! pm@debian.org */
+    if (arg == NULL)
+#endif
 	return POPT_ERROR_NULLARG;
 
     if (aLong != 0 && LF_ISSET(RANDOM)) {
